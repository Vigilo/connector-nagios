[bus]
# Nom ou adresse IP du serveur AMQP à utiliser.
host = localhost

# Nom d'utilisateur à utiliser pour se connecter au bus.
user = connector-nagios

# Mot de passe à utiliser
password = connector-nagios

# Chiffrement du flux par SSL
use_ssl = False

# Nom de la file d'attente du connecteur
queue = connector-nagios-localhost

# Liste des abonnements du connecteur, séparés par des virgules.
# Si la liste est vide, mettre uniquement une virgule.
# Syntaxe : <nom-du-noeud>[:<clé-de-routage>]
# Exemple : perf, nagios:Vigilo
subscriptions = nagios:all

# Le trafic lié au bus doit-il être enregistré dans les logs ?
log_traffic = False

#-----------------------------------------
# Réglages pour un grand volume de données

# Nombre de messages de performance à envoyer dans un même message.
#  * avantage : augmente très largement le débit maximum
#  * inconvénient : si les messages de performance ne sont pas générés assez
#    vite, leur relai peut être retardé (on attend que le paquet soit plein)
# La valeur 0 ou 1 désactive cet envoi par paquets.
batch_send_perf = 1


[connector-nagios]
# Liste des types de messages XML <command> que le connecteur-nagios
# acceptera de transmettre à Nagios, séparés par des virgules.
# Si la liste est vide, mettre uniquement une virgule.
accepted_commands = PROCESS_SERVICE_CHECK_RESULT, PROCESS_HOST_CHECK_RESULT, SCHEDULE_HOST_DOWNTIME, SCHEDULE_SVC_DOWNTIME, SCHEDULE_SVC_CHECK, SCHEDULE_HOST_CHECK, SCHEDULE_HOST_SVC_CHECKS, CHANGE_NORMAL_HOST_CHECK_INTERVAL, CHANGE_NORMAL_SVC_CHECK_INTERVAL, SEND_CUSTOM_HOST_NOTIFICATION, SEND_CUSTOM_SVC_NOTIFICATION

# Emplacement du socket utilisé pour recevoir des messages de Nagios.
listen_unix = @LOCALSTATEDIR@/lib/vigilo/connector-nagios/send.sock

# Emplacement du pipe utilisé pour envoyer des commandes à Nagios.
nagios_pipe = @NAGIOSCMDPIPE@

# Fichier de config distribué par VigiConf
nagios_config = @SYSCONFDIR@/vigilo/vigiconf/prod/nagios/nagios.cfg


[connector]
# Emplacement du fichier de sauvegarde local en cas de pannes.
backup_file = @LOCALSTATEDIR@/lib/vigilo/connector-nagios/backup.sqlite

# Nom de la table qui stocke les messages en attente à destination du bus.
backup_table = tobus

# Nom d'hôte utilisé pour signaler à Vigilo que ce connecteur fonctionne
# correctement. Cela doit correspondre au nom d'hôte configuré dans VigiConf
# pour cette machine. Par défaut, on utilise le nom d'hôte court (sans le
# domaine DNS)
#hostname = hostname

# Service utilisé pour signaler à Vigilo que ce connecteur fonctionne
# correctement. Comme ci-dessus, cela doit correspondre au nom de service
# configuré dans VigiConf.
#status_service = vigilo-connector-nagios

# L'exchange à utiliser pour les messages d'état du connecteur.
# Par défaut, la section [publications] est utilisée.
#status_exchange = connectors-status


[publications]
# Types de messages et le nom de l'exchange à utiliser pour leur publication.
# Par défaut, un exchange du même nom que le type est utilisé.
#perf = perf
#state = state
#event = event
#nagios = nagios


# -------
# Logging
#

[loggers]
keys = root,twisted

[handlers]
keys = syslog,console,errors

[formatters]
keys = consoleFormatter,syslogFormatter

[logger_root]
level = INFO
handlers = syslog,console,errors

[logger_twisted]
level = WARNING
qualname = twisted
propagate = 0
handlers = syslog,console,errors

[handler_console]
class = StreamHandler
level = NOTSET
formatter = consoleFormatter
args = (sys.stdout,)

[handler_syslog]
class = handlers.SysLogHandler
level = NOTSET
formatter = syslogFormatter
args = '/dev/log', 'daemon'

[handler_errors]
level = ERROR
class = handlers.RotatingFileHandler
args = ('@LOCALSTATEDIR@/log/vigilo/connector-nagios/error.log', 'a', 1024*1024*10, 5)
formatter = consoleFormatter

[formatter_consoleFormatter]
format = [%(created)f] %(levelname)s::%(name)s::%(message)s
datefmt =
class = vigilo.common.logging.VigiloFormatter

[formatter_syslogFormatter]
format = %(processName)s[%(process)d]: %(levelname)s::%(message)s
datefmt =
class = vigilo.common.logging.VigiloFormatter
